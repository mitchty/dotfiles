#+TITLE: My Solution To Dotfile Management
#+AUTHOR: Mitch Tishmack
#+STARTUP: hidestars
#+STARTUP: odd
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :cache yes :comments no :padline no

In the long long ago (2015), I used xstow and update-dotdee to construct my
dotfiles from tiny pieces of files.

I have since evolved to this setup. Originally the intention was to make it
easy for me to compile dotfiles based on certain parameters. Aka, my dotfiles
are the same for x, y, and z, whatever those are, but for certain cases z
should have one section be different or added etc... as the case may be.

Aka it was just a glorified program or templating system.

Since I already use org-mode to build my emacs configuration,
why not just do the same for the dotfiles. Bonus, now I can have ALL
my dotfiles in one logical file that can build itself.

So now if you want to look at my dotfiles, they're all in here. With one
caveat that my emacs configuration is not. That is still separate. Mostly
because it is large enough that it can be on its own.

* Use/Abuse

Use of this setup is simple. There really is one step in general:

#+BEGIN_SRC sh :tangle no
  make
#+END_SRC

But lets say you want to export things to another directory than $HOME. No
worries, just specify DEST:

#+BEGIN_SRC sh :tangle no
  make DEST=/some/other/directory
#+END_SRC

But wait, what if you want to export things for an os you're not using? No
worries, just copy options.el to name.el and specify that as OPTIONS too:

#+BEGIN_SRC sh :tangle no
  make DEST=/some/other/directory OPTIONS=osx
#+END_SRC

Want to copy a specific generation to somewhere else? Or maybe you tested
installing to some DEST, and want to copy that to $HOME? No worries:

#+BEGIN_SRC sh :tangle no
  make copy GEN=N
#+END_SRC

Where N is the generation you want to copy.

** How does it work?

It is really rather simple, the [[file:Makefile][Makefile]] isn't that complex. Look at that
for details.

This isn't intended to cover everything. This could be considered a template
for how you could setup your files in a similar way. Look at this org mode
file for details.

NOTE: Removal of files is YOUR job, not this tools. One could
theoretically look at what changed between two generations and
remove that way. BUT that sounds janky and error prone. Removal of
files is the users job, not this setup.

** Explanation of what is happening

The file [[file:defaults.el][defaults.el]] controls predicates that change how files get tangled to files.

This allows me to tangle files that would be useful for linux/bsd/etc...
without affecting the existing files.

The general idea is this (look at Makefile for details):
- increment generation count from last generation
- tangle files to tmp/$filename based on current settings
- copy tmp to generation/N
- iff generation/(N-1) exists, diff each file there to what exists at DEST
- If diffing fails, the destination files have been updated, STOP, might lose
  hand edited changes. Note, if destination does not exist, this is ignored.
  Also setting FORCE will ignore this check.
- If diffing does not fail, hardlink generation/N/$files to DEST/$files
- Update last with current generation.

Note, the destination can be anywhere, not just $HOME. This allows one to
compile/tangle files that can then be trivially rsynced to remote machines,
or to tar/xz the files as needed. The key here is emacs is only required
to generate config files, not necessarily to use them.

** How would I use this?

Should be easy enough to either clone this repo or copy things to a new repo
and hack in what you need. Your call.

But, say you have a heading, take .profile as an example, under an org mode
heading you would just add:

#+BEGIN_SRC org :tangle no
  :PROPERTIES:
  :header-args: :tangle tmp/.profile :comments no :padline no :cache yes :mkdirp yes
  :END:
#+END_SRC

Then any source blocks for that heading will go to tmp/.profile. Its important
that you put everything into ./tmp! This is used to generate things before a
generation is built. It gives the Makefile a chance to know if the tangling
worked or not.

But lets say you don't need to have lots of sub headings, or even control
a file in multiple subparts that have predicates to control things.

Pretty simple, just add a source block like normal:
#+BEGIN_SRC org :tangle no
  ,#+BEGIN_SRC conf :tangle tmp/.example.conf
  put contents here!
  ,#+END_SRC


#+END_SRC

* External Tanglers

Putting everything in readme.org was getting annoying. So started to split
things apart. Org links to all the


| name     | file           |
|----------+----------------|
| emacs    | [[file:emacs.org][emacs.org]]      |
| tmux     | [[file:tmux.org][tmux.org]]       |
| git      | [[file:git.org][git.org]]        |
| x        | [[file:x.org][x.org]]          |
| nix      | [[file:nix.org][nix.org]]        |
| zsh      | [[file:zsh.org][zsh.org]]        |
| vim      | [[file:vim.org][vim.org]]        |
| misc     | [[file:misc.org][misc.org]]       |
| .profile | [[file:dotprofile.org][dotprofile.org]] |
| ~/bin    | [[file:bin.org][bin.org]]        |

Language specific

| name    | file        |
|---------+-------------|
| haskell | [[file:haskell.org][haskell.org]] |
| perl    | [[file:perl.org][perl.org]]    |

* TODO
- [ ] Figure out some way to make code blocks editable with :tangle, it sucks not being able to edit blocks as they are.
- [ ] Need to have some way to autocleanup old generations. Rm works for now so meh.
- [ ] Need to add the ability to detect that make is generating a pointless new generation. Aka generation N and generation N-1 are the same, just leave N and don't increment.
- [ ] Maybe checksum file contents somehow and use that?
- [ ] More? For now its functional.

* Reference for babel stuff

Found this STUPID useful for constructing the tangle stuff.

[[https://raw.githubusercontent.com/eschulte/babel-dev/master/scraps.org][babel scraps link]]
